<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../three-js/three-js.html">
<!--
Polymer element wrapper for THREE.WebGLRenderer (http://threejs.org/docs/#Reference/Renderers/WebGLRenderer).

It manages GL rendering context across multiple instances of three-renderer.

All instances of this element will share a single WebGL canvas element. An element instance becomes a host of the canvas any time WebGL API is used through one of its methods. Before this happens, the previous host needs to store the framebuffer data in a 2D canvas before the WebGL canvas can be handed out.

IMPORTANT: Keep in mind that WebGL canvas migration is expensive and should not be performed continuously. In other words, you cannot render with mutliple instances of three-renderer in realtime without severe performance penalties.

@element three-renderer
@blurb Element wrapper for the THREE.WebGLRenderer.
-->

<dom-module id="three-renderer">
  <template>
    <link rel="stylesheet" type="text/css" href="three-renderer.css">
  </template>
  <script type="text/javascript">
    (function() {

      var renderer;
      var currentHost;
      var gl;

      var ctxPerfNow = 0;
      var ctxPerfDelta = 1000;
      var ctxPerfAverage = 1000;
      var ctxPerfWarned;

      /**
       * This function runs every time renderer migrates to another three-renderer host
       * It is designed to detect if migration feature is overrused by the user.
       */
      var performanceCheck = function() {
        if (ctxPerfWarned) return;
        ctxPerfDelta = performance.now() - ctxPerfNow;
        ctxPerfAverage = Math.min((ctxPerfAverage * 10 + ctxPerfDelta) / 11, 1000);
        ctxPerfNow = performance.now();
        if (ctxPerfAverage < 16) {
          console.warn('Performance warning: rendering multiple viewports!');
          ctxPerfWarned = true;
        }
      };

      /**
      * Renderer method that will be available on this element as proxy.
      * calling this method may triger renderer migration.
      * @method clear
      * @method setClearColor
      * @method setSize
      * @method render
      */
      var methods = ['clear', 'setSize', 'render', 'setViewport'];

      Polymer({
        is: 'three-renderer',
        publish: {
          // THREE.WebGLRenderer attributes
          autoClear: true,
          autoClearColor: true,
          autoClearDepth: true,
          autoClearStencil: true,
          gammaFactor: 2,
          gammaInput: false,
          gammaOutput: false,
          sortObjects: true,
          //
          clearColor: 0x666666,
          clearAlpha: 1,
          //
          width: 200,
          height: 200
        },

        observe: {
          'width height': 'resize',

          // TODO: remove
          'autoClear': 'update',
          'autoClearColor': 'update',
          'autoClearDepth': 'update',
          'autoClearStencil': 'update',
          'sortObjects': 'update',
          'gammaInput': 'update',
          'gammaOutput': 'update'
        },

        ready: function() {
          // Canvas2D used to store framebuffer pixels after renderer.domElement migration.
          this.canvas = document.createElement('canvas');
          this.canvas.id = 'canvas';
          this.ctx = this.canvas.getContext('2d');
          Polymer.dom(this.root).appendChild(this.canvas);

          // Detect WebGL support
          if (!Detector.webgl) {
            Polymer.dom(this.root).appendChild(Detector.getWebGLErrorMessage());
            return;
          }

          // Create renderer for the first time.
          if (!renderer) {
            renderer = new THREE.WebGLRenderer({
              antialias: true,
              preserveDrawingBuffer: true,
              alpha: false
            });
            gl = renderer.getContext();
            this.update();
          }

          // Create proxies for renderer methods
          methods.forEach(function(method) {
            this[method] = function() {
              this.setHost();
              renderer[method].apply(renderer, arguments);
            }
          }.bind(this));

        },

        attached: function() {
          this.resize();
        },

        // Set renderer parameters
        update: function() {
          renderer.autoClear = this.autoClear;
          renderer.autoClearColor = this.autoClearColor;
          renderer.autoClearDepth = this.autoClearDepth;
          renderer.autoClearStencil = this.autoClearStencil;
          renderer.gammaFactor = this.gammaFactor;
          renderer.gammaInput = this.gammaInput;
          renderer.gammaOutput = this.gammaOutput;
          renderer.sortObjects = this.sortObjects;
          renderer.setClearColor(this.clearColor);
          renderer.setClearAlpha(this.clearAlpha);
        },

        // Resize canvas2D automatically
        resize: function() {
          this.style.width = this.width + 'px';
          this.style.height = this.height + 'px';
          this.canvas.width = this.width;
          this.canvas.height = this.height;
          this.fire('three-renderer-resized');
        },

        /**
         * Migrate renderer.domElement to this host if necessary
         * and copy framebuffer into Canvas2D element of the previous host.
         */
        setHost: function() {
          if (this != currentHost) {
            performanceCheck();
            if (currentHost) {
              currentHost.ctx.drawImage(renderer.domElement, 0, 0, currentHost.canvas.width, currentHost.canvas.height);
              gl.flush();
              currentHost.canvas.style.display = 'block';
              currentHost.currentWidth = null;
              currentHost.currentHeight = null;
            }
            currentHost = this;
            this.setHostSize();
            Polymer.dom(this.root).appendChild(renderer.domElement);
            this.canvas.style.display = 'none';
            this.classList.toggle('rendering', true);
            requestAnimationFrame(function() {
              this.classList.toggle('rendering', false);
            }.bind(this));
            this.update();
          }
          this.setHostSize();
        },
        setHostSize: function() {
          if (this.currentWidth != this.width || this.currentHeight != this.height) {
            renderer.setSize(this.width, this.height);
            this.currentWidth = this.width;
            this.currentHeight = this.height;
          }
        },

      });

    })();
  </script>
</dom-module>
